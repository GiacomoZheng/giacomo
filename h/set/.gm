: ; !+ set
(
	∈ structure, ; define the isomorphism for the subclass of set
	; about ZFC (https://en.wikipedia.org/wiki/Zermelo–Fraenkel_set_theory)
		`Source: "The Foundations of Mathematics" --- Kenneth Kunen`,
		(
			"if two set has totally he same elements, they are the same set, it means, there has the same attributes defined by set class"
			∀A: ∈ set,
			∃B: ∈ set, ∀x: ∈ ◉, x ∈ A ⇔ x ∈ B
		), ; 1. extension,
		[ for example:
			``` A set.= B ⇒ A ∪ C set.= B ∪ C ```
		 ]

		(
			∀A: ∈ set,
			¬(A = ∅) ⇒
			(
				∃x: ∈ A, x ∈ set ⇒ x ∩ A = ∅ ; if not, correct ; ? pure set or not
			)
		), ; 2. regularity or fundation

		(
			∀A: ∈ set,
			∀cls: ⊆ ◉, ; ? set
			∃B: ∈ set, ∀x: ∈ B, x ∈ cls, x ∈ A
		), ; 3. specification, or comprehension

		; (
		; 	∃∅: ∈ set,
		; 	∀x: ∈ ◉, ¬(x ∈ ◉)
		; ), ; 3.2: empty set
		; can be proved by extension and comprehension axiom, add with the existence of empty class

		(
			∀A: ∈ set, ∀B: ∈ set,

		), ; 4. paring
		; (
		; 	∀x: ∈ ◉, ∃A: ∈ set,
		; 	∀y: ∈ A, y = x
		; ), ; 4.2: existence singleton set
		(

		)
	; end

	; * I cannot deal with the ⊆ ∈ (for class) and ⊆ ∈ (for set)
		; * idea 1: differ the symbol for classes and samples
		; * idea 2: give other symbols for class

	⊆ ◉, ; I may change it to, ∈ structure
	(
		∀X: ∈ set, ; +
		`
			my opinion about ZFC:
		`

		; attributes
			X.cover(∀S: ∈ sub(X)):
			(
				"cover of S in X",
				; * the element in it may be empty, as I define the topology as a cover later
				⊆ sub(Ps(X)), ; every element of the cover should be a subset of the X
				∀𝒞: ∈ X.cover(S),
				S ∈ sub(⋃(𝒞)) ; ! ⋃
			),
			X.partition:
			(
				⊆ X.cover(X),
				⊆ disjoint_sub(X),
				; ∀𝒫: ∈ X.partition(X), ; ¬({} ∈ 𝒫), ; ? for a partition, there can be an empty set inside, but it is not allowed in quotient
				; * In fact, I'm not sure about it, but I know
					; * covers can contain empty set
					; * quotient cannot contain empty set
			),
	),

	; location
		; about alias
			; ! countable: , ; this terminology may cause some ambiguity 
			; at_most_countable: = 
			countablely_infinite: = denumerable,
			enumerable: = denumerable, ; I don't think that using this term is a good idea indeed
		; end


		; + about structure
			sub(∀S: ∈ set): ; ?
			(
				"subset",
				⊆ set,
				∀A: ∈ sub(S),
				∀a: ∈ A, a ∈ S
			),

			Hom(∀S: ∈ set)(∀T: ∈ set): ; + the set of homomorphisms from S to T
			Epi(∀S: ∈ set)(∀T: ∈ set): ; +
			; Mon(∀S: ∈ set)(∀T: ∈ set): ; +
			End(∀S: ∈ set): ; +
			; Iso(∀S: ∈ set)(∀T: ∈ set): ; +
			Aut(∀S: ∈ set): ; +

			; + quotient
		; end

		; about special subsets
			disjoint_sub(∀S: ∈ set):
			(
				"disjoint subset",
				⊆ sub(S),
				∀X: ∈ disjoint_sub(S), ∀Y: ∈ disjoint_sub(S),
				¬(X = Y) ⇒ X ∩ Y = ∅
			),

			finite_sub(∀S: ∈ set):
			(
				"finite subset",
				⊆ finite, ; + to be define
				⊆ sub(S),
			),
			disjoint_finite_sub(∀S: ∈ set):
			(
				⊆ finite_sub(S),
				⊆ disjoint_sub(S),
			),
			
			countable_sub(∀S: ∈ set):
			(
				"countable subset",
				⊆ countable, ; ? countable I'm not sure about what it is 
				⊆ sub(S),
			),
			disjoint_countable_sub(∀S: ∈ set):
			(
				⊆ countable_sub(S),
				⊆ disjoint_sub(S),
			),
		; end

		quotient(∀S: ∈ set):
		(
			⊆ S.partition,
			∀𝒫: ∈ quotient(X),
			¬({} ∈ 𝒫) ; for the definition of quotient space / group
		),

		variable(∀D: ∈ set): ; ?
		(
			"a generalization of random variable in statistics",
			"a subset which can work as an element"
			; for example: [0, 1] + [2, 4] = [2, 4], we can read it as the summation of two variables",
			; + it will be use in analysis to define something like polynomial or dy/dx
			⊆ sub(D), ; Intuitively, the domain for it to pick some
			(
				∀X: ∈ variable(D),
				; + I need to find the operators or relators on set
			)
		),
		[ hierarchy chain: variable ⊇ random_variable ]

		element(∀S: ∈ set): ; +
		(
			"the class contains exactly what this S has; in another word, the class of elements of S",
		),

		Ps(∀S: ∈ set): = set.sub(S).collect(), ; return a set ; + set.sub(S) is collectible

		#(∀S: ∈ set):, ; + cardinal number of a set

		; + rewrite later (about universal property)
		×: ; !
		(
			∈ operator, ; !
			∀A: ∈ set, ∀B: ∈ set,
			A × B = {(x, y)}[∀x: ∈ A, ∀y: ∈ B]
		),

		∪: ; ! ; + rewrite later (about universal property)
		(
			; ∈
			∀τ: ∈ set, ; set of set
			∪[](τ) = {x}[∀x: ∈ ◉, ∃C: ∈ τ, x ∈ C],

			∀A: ∈ ◉, ∀B: ∈ ◉,
			∀(A ∈ set, B ∈ set) ⇒ (A ∪ B) = ∪[]({A, B})
		),

		∩: ; ! ; + rewrite later (about universal property)
		(
			; ∈

			∀τ: ∈ set, ; set of set
			∩[](τ) = {x}[∀x: ∈ ◉, ∀C: ∈ τ, x ∈ C], ; !

			∀A: ∈ ◉, ∀B: ∈ ◉,
			∀(A ∈ set, B ∈ set) ⇒ A ∩ B = ∩[]({A, B}) ; !
		),
),
