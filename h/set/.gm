: ; !+ set
(
	; about ZFC (https://en.wikipedia.org/wiki/Zermelo–Fraenkel_set_theory)
		(
			∀A: ∈ set,
			∃B: ∈ set, ∀x: ∈ ◉, x ∈ A ⇔ x ∈ B
		), ; 1. extension, ; ? I don't know why we need it

		(
			∀A: ∈ set,
			!(A = ∅) ⇒
			(
				∃x: ∈ A, x ∈ set ⇒ x ∩ A = ∅ ; ! if not?
			)
		), ; 2. regularity

		(
			∀A: ∈ set,
			∀cls: ◉.⊆ ◉,
			∃B: ∈ set, ∀x: ∈ B, x ∈ cls
		), ; 3. specification

		(
			∃∅: ∈ set,
			∀x: ∈ ◉, !(x ∈ ◉)
		), ; 3.2: empty set
		(
			∀x: ∈ ◉, ∃A: ∈ set,
			∀y: ∈ A, y = x
		), ; 3.3: existence singleton set
		(

		)
	; end

	; * I cannot deal with the ⊆ ∈ (for class) and ⊆ ∈ (for set)
	; * idea 1: differ the symbol for classes and samples
	; * idea 2: give other symbols for class

	◉.⊆ ◉,
	(
		∀X: ∈ set, ; +

		; attributes
			X.cover(∀S: ⊆ subset):
			(
				"cover of S, set of subsets",
				; * the element in it may be empty, as I define the topology as a cover latter
				◉.⊆ sub(Ps(S)), ; every element of the cover should be a subset of the S of it
				∀𝒞: ∈ X.cover(S),
				S ⊆ ∪(𝒞)
			),
	),

	; location
		; about alias
			; ! countable: , ; this terminology may cause some ambiguity 
			; at_most_countable: = 
			countablely_infinite: = denumerable,
			enumerable: = denumerable, ; I don't think using this term is a good idea indeed
		; end

		quotient(∀S: ∈ set):
		(
			◉.⊆ cover(S), ; ?

			∀𝒫: ∈ quotient(S),
			!({} ∈ 𝒫),; ? others may not require the sets in partition nonempty
			∀A: ∈ 𝒫, ∀B: ∈ 𝒫,
			!(A = B) ⇒ A ∩ B = ∅
		),

		sub(∀S: ∈ set):
		(
			"subset",
			◉.⊆ set,
			∀A: ∈ sub(S),
			∀a: ∈ A, a ∈ S
		),
		⊆: (∈ relator, &⊆&.r = sub), ; !

		element(∀S: ∈ set): ; +
		(
		),

		Ps(∀S: ∈ set): = {A}[∀A: ⊆ S], ; + return a set ; I'll create another function return a class

		equal(∀S: ∈ set): ; ?
		(
			◉.⊆ set,
		),
		=: (∈ relator, &=&.r = equal),

		×: ; !
		(
			∈ operator,
			∀A: ∈ set, ∀B: ∈ set,
			A × B = {(x, y)}[∀x: ∈ A, ∀y: ∈ B]
		),

		∪: ; !
		(
			; ∈
			∀τ: ∈ set, ; set of set
			∪[](τ) = {x}[∀x: ∈ ◉, ∃C: ∈ τ, x ∈ C],

			∀A: ∈ ◉, ∀B: ∈ ◉,
			∀(A ∈ set, B ∈ set) ⇒ (A ∪ B) = ∪[]({A, B})
		),

		∩: ; !
		(
			; ∈

			∀τ: ∈ set, ; set of set
			∩[](τ) = {x}[∀x: ∈ ◉, ∀C: ∈ τ, x ∈ C], ; !

			∀A: ∈ ◉, ∀B: ∈ ◉,
			∀(A ∈ set, B ∈ set) ⇒ A ∩ B = ∩[]({A, B}) ; !
		),
),
