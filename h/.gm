; about function
	; + I'll use subscript to define the function, may be f(x): = f.func[x]
	; with an input type (with a fixed classlevel) as well as an output type (with the same type)
	; for two input the same in the input type, it will give the same output from the output type

	function[∀A: ⊆ ◉][∀B: ⊆ ◉]: ; function from a class to a class ; ?
	(
		⊆ ◉,
		; keyword
		(
			∀f: ∈ function[A][B],
			f.input: ⊆ A, f.output: ⊆ B,
			f.map[∀x: ∈ f.input]: ∈ f.output, ; f map x to something

			@f,
				∀x: ∈ input, ∀y: ∈ output,
				x input.= y ⇒ map[x] output.= map[y]
			■
		)
	),
	; a functor is in some sense a function[class][class], not defined yet

; end

; about set
	set[∀cls: ⊆ ◉]:
	(
		⊆ set,
		∀S: ∈ set,
		S.universe = cls
	),
	; set[set] is pure_set in set sense
; end

; about operators and relators
	operator[∀p: ∈ operation]: ; ?
	(
		∈ operator,
		&operator[p]&.operation = p
	),

	relator[∀R: ∈ relation]: ; ?
	(
		∈ relator,
		&relator[p]&.relation = R
	),
; end

; ? about compound structures
	; on algebra
	; + I'll create something like "#[add_subscript]" in `rust` to simplify it
		associative_algebra: = algebra,
		algebra[∀R: ∈ commutative_ring]: = R.algebra,
		associative_algebra[∀R: ∈ commutative_ring]: = algebra[R],
		
		commutative_algebra[∀R: ∈ commutative_ring]: = R.commutative_algebra,

		reduced_algebra[∀R: ∈ commutative_ring]: = R.reduced_algebra,
	; end

	; on field
		; vector_space[∀F: ∈ field]:
	; end
; end

; ! about variable
	variable(∀D: ∈ set): ; ?
	(
		"a generalization of random variable in statistics",
		"a subset which can work as an element"
		; for example: [0, 1] + [2, 4] = [2, 4], we can read it as the summation of two variables",
		; + it will be use in analysis to define something like polynomial or dy/dx
		⊆ set.sub(D), ; Intuitively, the domain for it to pick some
		(
			∀X: ∈ variable,
			; * a subclass of set, may catch some operators with it
		)
	),
	[ hierarchy chain: variable ⊇ random_variable ] ; !

	constant(∀x: ∈ variable): ; +
	(
		; ⊆ variable
	)
; end

; about alias
	; ? about class
		empty_class: = class.empty,
			contradiction: = class.empty,
			paradox: = class.empty,
		consistent_class: = class.nonempty, ; * Source K. Kunen's "The Foundation of Mathematics" Definition II.7.13
			satisfiable_class: = class.nonempty, ; * Source K. Kunen's "The Foundation of Mathematics" Definition II.7.13
				
		collectible_class: = class.collectible,
		proper_class: = class.proper,

		singleton_class: = class.singleton,
		absolute_singleton_class: = class.absolute_singleton,
		at_most_singleton_class: = class.at_most_singleton,

	; end 
	; about structure
		singleton_structure: = structure.singleton,
		universal_structure: = structure.universal,
	; end
	
	; about set
		; about morphisms
			mapping: = set.homomorphism,
				map: = set.homomorphism,
			injection: = set.monomorphism,
			surjection: = set.epimorphism,
			bijection: = set.isomorphism,
			; set.endomorphism, ; no such a set version yet
			permutation: = set.automorphism,
			identity_map: = set.identity_morphism,
		; end

		cover(∀X: ∈ set): = X.cover(X),
		partition(∀X: ∈ set): = X.partition,
	; end

	; about name of structures
		; about commutative
			commutative_group: = abelian_group,

			commutative_domain: = integral_domain,
			commutative_rng: = rng.commutative,
			commutative_ring: = ring.commutative,
			commutative_algebra: = algebra.commutative
		; end

		unital_rng: = ring, ; ? I think it useless
		unital_ring: = ring,
		doman: = rng.domain,
		; ! domain: = ring.domain, ; a little bit confusing
		non_zero_ring: = ring.non_zero,
		nonzero_ring: = ring.non_zero,
		associative_algebra: = algebra,
		skew_field: = division_ring,
		unital_module: = ring.module, ; left module
		; ! module: = ring.module, ; a little bit confusing
		vector_space: = field.module,
		; ? linear_space: = field.module,
		finite_dimensional_vector_space: = field.module.finite_dimensional,

		partial-ordered_set: = poset,
			partial_ordered_set: = poset,
		totally_ordered_set: = totally-ordered_set,
			linearly_ordered_set: = totally-ordered_set,
		well_ordered_set: = well-ordered_set,
			least_well_ordered_set: = well-ordered_set,
			least_ordered_set: = well-ordered_set,
		supremum_ordered_set: = supremum-ordered_set,
			; ? complete-ordered_set: = supremum-ordered_set,
			; ? complete_ordered_set: = supremum-ordered_set,
		filtrant-ordered_set: = directed-ordered_set,
			directed_ordered_set: = directed-ordered_set,
			filtrant_ordered_set: = directed-ordered_set,
		inductive_set: = inductively-ordered_set,
			inductively_ordered_set: = inductively-ordered_set,

		bounded_poset: = poset.bounded,
			bounded_above_poset: = poset.bounded_above,
			bounded_below_poset: = poset.bounded_below,
		
		top'space: = topological_space, ; My (year 2) topology teacher use it

		; ! simplicial_complex: = abstract_simplicial_complex, ; the latter maight be confusing
		CW_complex: = cell_complex, ; refernce: Allen Hatcher - Algebraic Topology
	; end

	; about function
		∘: = &set.homomorphism.∘&, ; !
	; end

	; about operation
		associative_operation: = operation.associative,
		commutative_operation: = operation.commutative,
		idempotent_operation: = operation.idempotent
	; end

	; ! about relation
		multivalued_function: = set.relation, ; ? I'll use it is complex analysis
		
		endo_relation: = endorelation,
		homogeneous_relation: = endorelation,

		reflexive_relation: = relation.reflexive,
		transitive_relation: = relation.transitive,
		symmetric_relation: = relation.symmetric,

		irreflexive_relation: = relation.irreflexive,
		antitransitive_relation: = relation.antitransitive,
		antisymmetric_relation: = relation.antisymmetric,

		preorder_relation: = relation.preorder,

		equivalent_relation: = relation.equivalent,
		order_relation: = relation.order,
	; end

	; about topology
		continuous_function: = topological_space.continuous_function,
		bicontinuous_function: = topological_space.homeomorphism,
		; topological_isomorphism: = topological_space.isomorphism,
		identification_space: = topological_space.quotient,
	; end

	; about poset
		linear_continuum: = linearly-ordered_set.continuum, ; as it is a linearly-ordered_set
	; end

	; about vector space (field.module)
		linear_transformation: = field.module.homomorphism,
		linear_map: = field.module.homomorphism, ; some one may use it
		linear_operator: = field.module.endomorphism. ; * I do not like this name

		; about real vector space
			ℝ-vector_space: = ℝ.vector_space,
			real_vector_space: = ℝ.vector_space,
			finite_dimensional_real_vector_space: = ℝ.vector_space.
		; end
	; end

	; about attributes of structure
		; ? about trivial
			trivial_group: = group.trivial,
			trivial_rng: = rng.trivial,
			topological_trivial_space: = topological_space.trivial,
			trivial_vector_space: = field.module.trivial,
		; end

		; about sub structure
			substructure: = structure.sub,
		
			subgroup: = group.sub,
			subrng: = rng.sub,
			subring: = ring.sub,
			subfield: = field.sub,
			vector_subspace: = field.module.sub,
				; linear_subspace: = field.module.sub,
			topological_subspace: = topological_space.sub,

			; about topological space
				connected_subspace: = topological_space.connected_sub,
				dense_subspace: = topological_space.dense_sub,
			; end
			; about group
				normal_subgroup: = group.normal_sub,
				commutator_subgroup: = group.commutator_sub,
				derived_subgroup: = group.commutator_sub,
			; end
		; end
	; end

	; ! about complex
		; about simplicial_complex
			simplicial_map: = abstract_simplicial_complex.homomorphism, ; ?
		; end
	; end

	; + about analysis
		; about real analysis
		
		; end

		; about complex analysis
			complex_function: = ℂ.function,
		; end
	; end

	; about number theory

	; end
; end
