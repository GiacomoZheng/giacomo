: ; commutative_ring
(
	⊆ ring,
	⊆ commutative_rng,

	; 
		; about alias
			ED: = Euclidean_domain,
			Bezout_domain: = Bézout_domain, ; for convenience
		; end

		; about inheritance
			principle_ideal(∀R: ∈ commutative_ring): = commutative_rng.principle_ideal(R),
		
			P[∀R: ∈ commutative_ring]: ; !
			(
				"a polynomial ring over R"
				S[∀n: ∈ h.N]: = {m|h.N.0 ≤ m < n}[∀m: ∈ h.N], ; pre definition

				∈ function,
				∀R': (∈ commutative_ring, R ∈ sub(R')),
				∀x: ∈ R', ; ? I don't know whether I need to write ∀x: ∈ ◉,
				P[R](x) = {+[∀n: ∈ S[m]](c[n] R.× (x R.^ n))}[∀m: ∈ h.N, ∀n: ∈ S[m], ∀c[∀n: ∈ S[m]]: ∈ R]
				; we can prove it is unique under the consistent definitions
			),

			common_divisor[∀R: ∈ commutative_ring]: = commutative_rng.common_divisor[R],

			gcd[∀R: ∈ commutative_ring]: = commutative_rng.gcd[R],
			
			unit(∀R: ∈ commutative_ring): = ring.unit(R),

			divisor[∀R: ∈ commutative_ring]: = commutative_rng.divisor[R],

			zero_divisor(∀R: ∈ commutative_ring): = commutative_rng.zero_divisor(R),
			; in an integral domain, the only zero divisor is 0 (according to my definition)

			multiple[∀R: ∈ commutative_ring]: = commutative_rng.multiple[R],
		; end

),