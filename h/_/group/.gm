: ; group
(
	⊆ monoid, ; semigroup with identity
	(
		∀G: ∈ group,
		∃x': ∈ G, x' G.* x = x G.* x' = G.e, ; inverse
		; attributes
			; ! I won't define G.^ as it will be confused with it in ring
			; ! I won't define G./ as it will be confused with it in commutative_ring

			; ? about coset
				; I may move it to somewhere like magma
				G.l'coset(∀H: ∈ sub(G)):
				(
					⊆ set,
					∀C: ∈ G.l'coset(H),
					∃g: ∈ G, C = {g G.* h}[∀h: ∈ H] ; Order
				),
				G.left_coset: = G.l'coset,
	
				G.r'coset(∀H: ∈ sub(G)):
				(
					⊆ set,
					∀C: ∈ G.r'coset(H),
					∃g: ∈ G, C = {h G.* g}[∀h: ∈ H] ; Order
				),
				G.right_coset: = G.r'coset,

				G.coset(∀N: ∈ normal(G)): = G.l'coset(N),
			; end

	),
	[ hierarchy chain: group ⊆ monoid ⊆ semigroup ⊆ magma ]

	; the "group" above is just a location for the ones below
		; about alias
			ker(∀f: ∈ homomorphism): = f.kernel,

			periodic_group: = torsion_group,
			l'action: = action,
				left_action: = l'action,
			r'action: = anti_action,
				right_action: = r'action,
			
			

			; about coset
				l'coset[∀G: ∈ group]: = G.l'coset,
					left_coset: = G.l'coset,
				r'coset[∀G: ∈ group]: = G.r'coset,
					right_coset: = G.r'coset,
				coset[∀G: ∈ group]: = G.coset,
			; end
		; end

		; + about inheritance
			sub(∀G: ∈ group):
			(
				"a subset who is also an induced group",
				⊆ set.sub(G),
				⊆ group,

				∀H: ∈ sub(G),
				H.e = G.e,
				&H.*& = &G.*&
			),

			×: ; ?
			(
				"product space: the result of it is indeed a group",
				∈ operator, ; !
				∀A: ∈ group, ∀B: ∈ group,
				(A × B) set.= A set.× B,
				(A × B).*:
				(
					∀{(x1, y1), (x2, y2)}: ⊆ A × B,
					(x1, y1) (A × B).* (x2, y2) = (x1 A.* x2, y1 A.* y2)
				)
			),

			Hom(∀G: ∈ group, ∀H: ∈ group): = {f|f ∈ homomorphism}[∀f: ∈ set.Hom(G, H)], ; +

			quotient(∀G: ∈ group): ; +
			(
				⊆ set.quotient(G), ; + may be I should use varibale to define it
				⊆ group,
				∀Q: ∈ quotient(G),
				Q.e ∈ normal(G),
				∀x: ∈ Q, ∃g: ∈ G, 
				; +
			)
		; end

		; about basic
			inv[∀G: ∈ group](∀g: ∈ G):
			(
				[ valid because the unqeness of the inverse in the group  ]
				@G,
				∃g': ∈ G, g' * g = g * g' = e,
				= g'
				■
			),

			order[∀G: ∈ group](∀x: ∈ G):
			(
				"it is the cardinal of the smallest subgroup of G with x  in it, generally speaking"
				D: = {m}[∀m: ∈ N, G.e (G.* x)^m = G.e] ; !
				¬(D = ∅) ⇒ order[G](x) = inf(D) ; the domian of inf function do not contains ∅. If so, the error will occur; ! I may change the inf function later
				; + otherwise return the cardinal of Z
			),

			; span[∀G: ∈ group](∀A: ⊆ G): = {},

			isomorphic(∀G: ∈ group):
			(
				⊆ group,
				∀H: ∈ isomorphic(G),
				∃f: ∈ isomorphism, ∀(f.D = G, f.C = H)
			),
			≌: (∈ relator, &≌&.r = isomorphic),
			[ ≌ is an equivalent relator ]
		; end

		; about normal subgroup and quotient group
			/["l"]: ; ?
			(
				∈ operator, ; !
				∀G: ∈ group, ∀H: ∈ sub(G),
				G /["l"] H = {∀x: ∈ l'coset[G](H)}
			),

			/["r"]: ; ?
			(
				∈ operator, ; !
				∀G: ∈ group, ∀H: ∈ sub(G),
				G /["r"] H = {∀x: ∈ r'coset[G](H)}
			),

			conjugate[∀G: ∈ group](∀a: ∈ G): ; if b ∈ conjugate(a), we can say that a and b is conjugate	
			(
				⊆ set.element(G),
				∀b: ∈ conjugate[G](a),
				∃g: ∈ G, g G.* a G.* inv[G](g)
			),

			normal(∀G: ∈ group):
			(
				⊆ sub(G),
				∀N: ∈ normal(G),
				∀g: ∈ G, g ∈ G.normalizer(N) ; g * N * inv[G](g) ∈ N
			),
			normal_sub: = normal,

			/: ; !
			(
				∈ operator, ; !
				∀G: ∈ group, ∀H: ∈ normal(G),
				G / H = G /["l"] H ; in fact, here /[l] and /[r] has the same result
			),
		; end
		
		; about centralizer and normalizer
			centralizer[∀G: ∈ group](∀A: ⊆ G): = {g|∀a: ∈ A, a G.* g = g G.* a}[∀g: ∈ G],
				C[∀G: ∈ group]: = centralizer[G]
			center(∀G: ∈ group): = centralizer[G](G),
				Z: = center, ; ?
			normalizer[∀G: ∈ group](∀A: ⊆ G): = {g|∀a: ∈ A, g G.* a G.* inv[G](g) ∈ A}[∀g: ∈ G],
				N[∀G: ∈ group]: = normalizer[G],
		; end
		
		commutator_sub(∀G: ∈ group): = min_sub[G]({a G.* b G.* inv[G](a) G.* inv[G](b)}[∀{a, b}: ⊆ G]), ; Commutator subgroup, or derived subgroup ; ?
			derived_sub: = commutator_sub,
		[ commutator_sub(G) ∈ normal(G) ]
),
