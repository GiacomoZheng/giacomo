: ; class
(
	"the '?' of all class, the biggest thing in the classlevel 2",
	∋ ◉, ; * it means `class` contains ◉ and all of its subclasses

	; loaction
		sub(∀c: ∈ class):
		(
			⊆ class, ; ! ⊆ is not defined yet
			∀b: ∈ sub(c),
			∀x: ∈ b, x ∈ c
		),
		
		empty: ; or empty_class, or contradiction, or paradox
		(
			; + 
			; a subclass of a empty_class must be an empty_class  
			"there is no instance for this class: there is some contradiction within the criteria",

		),
		
		nonempty: ; or nonempty_class, or consistent_class, or satisfiable_class
		(
			; +
			; a subclass of a nonempty_class might be an empty_class  
			"there is some instance for this class",

		),
			non-empty: = nonempty,
			consistent: = nonempty, ; * Source K. Kunen's "The Foundation of Mathematics" Definition II.7.13
			satisfiable: = nonempty, ; * Source K. Kunen's "The Foundation of Mathematics" Definition II.7.13

		singleton: ; or singleton_class
		(
			"instance (sample) of this class is unique"
			⊆ nonempty,

			∀s: ∈ singleton, 
			∀X: ∈ s, ∀Y: ∈ s,
			X s.= Y, ; so that ◉ is a singleton
			; X = Y, ; what if? ; ? I may name it as `absolute singleton`

			; attributes
				s.instance:
				(
					; safe
					"pick the (only) element of s",
					∃X: ∈ s,
					= X
				),
					s.sample: = s.instance,
					s.take(): = s.instance, ; in rust manner
		),

		; unique_

		collectible: ; or collectible_class
		(
			; in rust manner
			"set-lizible: the class can be \"collected\" as a set",
			⊆ class,
			; ! I'll fix it after I determine the definition of set

			∀s: ∈ collectible,
			∃S: ∈ set,
			S.element class.= s ; S.element is the class with only the elements in 

			; attributes
				s.collected: set.= S, ; convert a collectible class into a set
		),
		[ preoperties:
			* empty ⊆ collectible => ∅,
			* singleton ⊆ collectible => {e}, 
			* `◉` is not collectible
		]

		proper: ; or proper_class
		(
			"the class is to big to be collectible",
			; +
		),

		collect(∀s: ∈ collectible): = s.collected,

		sub(∀x: ∈ class): ; +

),